<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://wannesmalfait.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://wannesmalfait.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-09-20T13:20:26+00:00</updated><id>https://wannesmalfait.github.io/feed.xml</id><title type="html">blank</title><subtitle>Wannes Malfait&apos;s personal website. </subtitle><entry><title type="html">Computing prime numbers in parallel</title><link href="https://wannesmalfait.github.io/blog/2024/parallel-primes/" rel="alternate" type="text/html" title="Computing prime numbers in parallel"/><published>2024-06-05T00:00:00+00:00</published><updated>2024-06-05T00:00:00+00:00</updated><id>https://wannesmalfait.github.io/blog/2024/parallel-primes</id><content type="html" xml:base="https://wannesmalfait.github.io/blog/2024/parallel-primes/"><![CDATA[<h2 id="the-problem-statement">The problem statement</h2> <p>Given an integer <code class="language-plaintext highlighter-rouge">n</code>, the goal is to compute all the prime numbers less than or equal to <code class="language-plaintext highlighter-rouge">n</code>.</p> <p>Most programmers have probably written a program to do exactly this at least once in their life. I recently needed this for <a href="https://github.com/WannesMalfait/prime-sum-sequences">a program</a> I was writing to compute “prime sum sequences”: permutations of the numbers <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">n</code> such that the sum of two consecutive numbers is always a prime, e.g., <code class="language-plaintext highlighter-rouge">1,4,3,2,5,6</code>.</p> <h2 id="the-solution">The solution</h2> <p>We will be writing all the code in rust, because I like writing things in rust, and because it is easy to write high-performance parallel code in.</p> <h3 id="a-naive-implementation">A naive implementation</h3> <p>Let us start with perhaps the most simple implementation:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">compute_primes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="n">i</span><span class="p">)</span><span class="nf">.all</span><span class="p">(|</span><span class="n">divisor</span><span class="p">|</span> <span class="n">i</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
        <span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>We make heavy use of iterators here. The code almost reads like the definition of a prime number: A number \(i &gt; 1\) is prime, if it has no non-trivial divisors, i.e., for all \(j \in {2, 3, \dotsc, i -1 }\), the number \(j\) does not divide \(i\). For those less familiar with iterators, here is a version with classic for loops:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">compute_primes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">primes</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..=</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">is_prime</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">divisor</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..</span><span class="n">i</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">is_prime</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
                <span class="k">break</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">is_prime</span> <span class="p">{</span>
            <span class="n">primes</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">primes</span>
<span class="p">}</span>
</code></pre></div></div> <p>Let us now clean this up a bit by splitting the primality check into a separate function:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">..*</span><span class="n">n</span><span class="p">)</span><span class="nf">.all</span><span class="p">(|</span><span class="n">divisor</span><span class="p">|</span> <span class="n">n</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">compute_primes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.filter</span><span class="p">(</span><span class="n">is_prime</span><span class="p">)</span><span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>It is now trivial to parallelize this with rayon:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">rayon</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">..*</span><span class="n">n</span><span class="p">)</span><span class="nf">.all</span><span class="p">(|</span><span class="n">divisor</span><span class="p">|</span> <span class="n">n</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">compute_primes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.into_par_iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(</span><span class="n">is_prime</span><span class="p">)</span><span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>That is quite elegant and neat. We can still speed this up by a lot, because we are doing a lot of redundant work.</p> <h3 id="removing-redundant-checks">Removing redundant checks</h3> <p>Observe that if \(n = a \cdot b\), then either \(a \leq \sqrt{n}\) or \(b \leq \sqrt{n}\). Indeed, otherwise we would have \(a &gt; \sqrt{n}\) and \(b &gt; \sqrt{n}\) from which \[ n = a \cdot b &gt; \sqrt{n} \cdot \sqrt{n} = n, \] a contradiction. So, it suffices to check for divisors less than the square root of \(n\). Alternatively, one can check that the square of the divisor is less than \(n\). To avoid potential overflows we use a saturated multiplication:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="c1">// Note that i &lt;= sqrt(n) if and only if i^2 &lt;= n.</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">..*</span><span class="n">n</span><span class="p">)</span>
        <span class="nf">.take_while</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span><span class="nf">.saturating_mul</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
        <span class="nf">.all</span><span class="p">(|</span><span class="n">divisor</span><span class="p">|</span> <span class="n">n</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>Note that this is a big reduction in complexity, e.g., to check if 1000 is prime we now only need to check 31 numbers, instead of 1000.</p> <p>The next observation is that we only need to check if the number is divisible by prime numbers, since every number is a product of prime numbers. However, to implement this, we already need a list of prime numbers! Luckily we can get around this:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// `primes` should contain at least all primes less than sqrt(n).</span>
<span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">primes</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="n">primes</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.take_while</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span><span class="nf">.saturating_mul</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
        <span class="nf">.all</span><span class="p">(|</span><span class="n">prime</span><span class="p">|</span> <span class="n">n</span> <span class="o">%</span> <span class="n">prime</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">compute_primes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// We can no longer use filter -&gt; collect,</span>
    <span class="c1">// because we need primes while iterating.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">primes</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..=</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primes</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">primes</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">primes</span>
<span class="p">}</span>
</code></pre></div></div> <p>The good news is that this also gives a nice reduction in complexity. One can show that the number of primes less than \(n\) is approximately \(n / \ln{n}\), where \(\ln\) denotes the natural logarithm. So we have gone from \(O(n)\) to \(O(\sqrt{n})\) to \[ O\left(\frac{\sqrt(n)}{\ln{\sqrt(n)}}\right) = O\left(2 \cdot \frac{\sqrt{n}}{\ln{n}}\right) = O\left(\frac{\sqrt{n}}{\ln{n}}\right). \] Concretely, from checking 1000 numbers, to checking 30 numbers, to checking just 11. For 10000, we go to 100 and then down to 25. That is quite the reduction!</p> <p>The bad news is that we have lost our parallel iterator. We will now see how we can get it back.</p> <h3 id="back-to-parallelism">Back to parallelism</h3> <p>The main issue is that our main loop has gone from a parallel loop to a sequential one. Previously, the <code class="language-plaintext highlighter-rouge">is_prime</code> function only depended on the current number in the loop. Now, <code class="language-plaintext highlighter-rouge">is_prime</code> also depends on the already computed list of primes. Thus, <code class="language-plaintext highlighter-rouge">is_prime(n+1)</code> can only be computed after <code class="language-plaintext highlighter-rouge">is_prime(n)</code> has been computed. This prevents a simple parallelization of the loop.</p> <p>The key insight is that we don’t actually need to know all the primes up to <code class="language-plaintext highlighter-rouge">n</code> to compute <code class="language-plaintext highlighter-rouge">is_prime(n)</code>. As we already observed, we only need to know the primes up to \(\sqrt{n}\). For example, if we already know the primes up to 100, we can safely compute all the primes up to \(100^2 = 10000\) using the list of primes up to 100. This gives the final algorithm:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">rayon</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">min</span><span class="p">;</span>

<span class="c1">// `primes` should contain at least all primes less than sqrt(n).</span>
<span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">primes</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="n">primes</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.take_while</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span><span class="nf">.saturating_mul</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
        <span class="nf">.all</span><span class="p">(|</span><span class="n">prime</span><span class="p">|</span> <span class="n">n</span> <span class="o">%</span> <span class="n">prime</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">compute_primes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">primes</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="c1">// We first compute some initial primes on 1 thread,</span>
    <span class="c1">// since to properly iterate in parallel we need to already</span>
    <span class="c1">// have a decent number of primes.</span>
    <span class="k">let</span> <span class="n">initial_cutoff</span> <span class="o">=</span> <span class="mi">5_000</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cap</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">initial_cutoff</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..=</span><span class="n">cap</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primes</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">primes</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Now we can iterate in parallel.</span>
    <span class="k">while</span> <span class="n">cap</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">// We know the primes up to cap,</span>
        <span class="c1">// so we can compute the primes up to</span>
        <span class="c1">// cap^2.</span>
        <span class="n">cap</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">cap</span><span class="nf">.saturating_mul</span><span class="p">(</span><span class="n">cap</span><span class="p">));</span>

        <span class="k">let</span> <span class="n">new_primes</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="o">..=</span><span class="n">cap</span><span class="p">)</span>
            <span class="nf">.into_par_iter</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primes</span><span class="p">))</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>
        <span class="n">primes</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_primes</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">primes</span>
<span class="p">}</span>
</code></pre></div></div> <p>For my laptop with 8 threads, this parallel version was around 6 times faster than the single-threaded version. This indicates that the parallelism works quite well.</p> <h2 id="closing-remarks">Closing remarks</h2> <p>The final algorithm as it is written is not fully optimized. Things that could be added include:</p> <ul> <li>Only iterate over odd numbers. This seems like it halves execution time, but in reality doesn’t make a big difference. The reason is that being even is always the first thing being checked in <code class="language-plaintext highlighter-rouge">is_prime</code>, so skipping over even numbers only skips numbers that would be rejected quickly anyway.</li> <li>Allocate space for the <code class="language-plaintext highlighter-rouge">primes</code> vector ahead of time using the <code class="language-plaintext highlighter-rouge">n / ln(n)</code> approximation for its size. This might give a minor improvement in speed.</li> <li>Choose an <code class="language-plaintext highlighter-rouge">initial_cutoff</code> value depending on the number of threads. The value I picked is somewhat arbitrary, but seemed to work well on my laptop.</li> </ul> <p>I decided to make this blog post because I couldn’t find any decent parallel prime generating functions when I searched for it online. After thinking about it a bit myself, I ended up with the above algorithm and then made this blog post, so others can use it too. Over all, I am quite pleased with the result.</p>]]></content><author><name></name></author><category term="programming"/><category term="rust"/><summary type="html"><![CDATA[Coming up with an algorithm to compute primes in parallel]]></summary></entry><entry><title type="html">LaTeX compilation with GitHub actions</title><link href="https://wannesmalfait.github.io/blog/2024/github-latex-ci/" rel="alternate" type="text/html" title="LaTeX compilation with GitHub actions"/><published>2024-03-16T00:00:00+00:00</published><updated>2024-03-16T00:00:00+00:00</updated><id>https://wannesmalfait.github.io/blog/2024/github-latex-ci</id><content type="html" xml:base="https://wannesmalfait.github.io/blog/2024/github-latex-ci/"><![CDATA[<h2 id="why-i-wanted-to-compile-latex-code-with-github-actions">Why I wanted to compile LaTeX code with GitHub actions</h2> <p>Whenever I write a document in LaTeX, I set up a (local) git repository for version control. This lets me make big changes without having to worry about permanently deleting things that I might need in the future. By looking at the commit log, I can get a quick overview of what I was working on, after revisiting the document after some time. Because LaTeX generates a lot of extra files on compilation, I have a <code class="language-plaintext highlighter-rouge">.gitignore</code> file set up to essentially ignore everything that isn’t a <code class="language-plaintext highlighter-rouge">.bib</code> or a <code class="language-plaintext highlighter-rouge">.tex</code> file. Importantly, I ignore <code class="language-plaintext highlighter-rouge">.pdf</code> files. There are a couple of reasons for this:</p> <ol> <li>As a general rule of thumb, only source files should be included in a git repository. The compilation outputs can be recreated from the source files, and do not carry extra information.</li> <li>A <code class="language-plaintext highlighter-rouge">.pdf</code> file is relatively big. It can easily be 10 times the size of the source file.</li> <li>The binary data of the output <code class="language-plaintext highlighter-rouge">.pdf</code> file can change quite drastically, even after making small changes to <code class="language-plaintext highlighter-rouge">.tex</code> source. This makes it quite useless to use something like <code class="language-plaintext highlighter-rouge">git diff</code> directly on the PDF. Instead, a tool like <a href="https://ctan.org/pkg/latexdiff">latexdiff</a> should be used.</li> <li>I often only compile a small part of the whole document, to speed up compilation time. The output PDF’s do not reflect the “actual” state of the document, and shouldn’t be picked up by the version control.</li> </ol> <p>My only problem, so far, with this approach, was that I didn’t have an easy way to share the PDF with my supervisors. Every time I wanted to share a version, I had to compile the full document, and e-mail them the PDF. This is not terribly difficult to do, but it annoyed me slightly. Additionally, I wanted my supervisors to be able to view the latest version or a previous version at any time, without me having to spam them with e-mails.</p> <h2 id="my-solution">My solution</h2> <p>Setting up a simple GitHub action workflow, was surprisingly easy. A few searches on the web and some copy-pasting from README examples got me there. Here’s the code:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># .github/workflows/compile.yml</span>
<span class="na">name</span><span class="pi">:</span> <span class="s">Build LaTeX document</span>
<span class="na">on</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">push</span><span class="pi">]</span>
<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build_latex</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">permissions</span><span class="pi">:</span>
      <span class="na">contents</span><span class="pi">:</span> <span class="s">write</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Get current date</span>
        <span class="na">id</span><span class="pi">:</span> <span class="s">date</span> 
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span> <span class="c1"># You can change the time zone if needed</span>
            <span class="s">echo "date=$(TZ='Europe/Brussels' date +'%Y-%m-%d--%H-%M')" &gt;&gt; $GITHUB_ENV</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set up Git repository</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v4</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Compile LaTeX document</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">xu-cheng/latex-action@v3</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">root_file</span><span class="pi">:</span> <span class="s">main.tex</span> <span class="c1"># Change to the name of your main file </span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Upload PDF file to new release</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">ncipollo/release-action@v1</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">tag</span><span class="pi">:</span> <span class="s">${{ env.date }}</span>
          <span class="na">commit</span><span class="pi">:</span> <span class="s2">"</span><span class="s">main"</span> <span class="c1"># The name of the branch to commit to</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">${{ env.date }}</span>
          <span class="na">artifacts</span><span class="pi">:</span> <span class="s2">"</span><span class="s">main.pdf"</span> <span class="c1"># Make sure this is the same name as your main file</span>
</code></pre></div></div> <p>It works quite well, but there are some things which you might not like:</p> <ul> <li>This creates a new release on every push to the GitHub repository. I first tried just uploading the compiled PDF to an artifact instead of a release. The problem is that these can not be accessed without being logged in to GitHub, and they don’t have an easily accessible download link.</li> <li>I have not bothered to collect all the commit names into a change log for each release. That could be a possible improvement. Right now, the release just has the current date/time as its name and tag. This ensures it doesn’t accidentally get overwritten, but it could also be formatted a bit more nicely.</li> <li>The <code class="language-plaintext highlighter-rouge">latex-action</code> uses a full <code class="language-plaintext highlighter-rouge">texlive</code> environment. Currently, the full release workflow takes around 2 minutes to complete. This could probably be shortened by using a more minimal LaTeX environment.</li> </ul> <p>Over all, I’m happy with the result I got for the small amount of time I put into it.</p>]]></content><author><name></name></author><category term="GitHub"/><category term="LaTeX"/><category term="programming"/><summary type="html"><![CDATA[Setting up GitHub actions to compile LaTeX documents on push]]></summary></entry></feed>