<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Computing prime numbers in parallel | Wannes Malfait </title> <meta name="author" content="Wannes Malfait"> <meta name="description" content="Coming up with an algorithm to compute primes in parallel"> <meta name="keywords" content="Wannes, Malfait, math, programming, blog, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-base16-one-light.css?8393edac9c74c8e932162511ccb836cb" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/prof_pic.jpg?ce724c3fd1117062ca8348fb92c1a4d0"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://wannesmalfait.github.io/blog/2024/parallel-primes/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-base16-onedark.css?06177c82442acf647f52dcdd34132254" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Wannes</span> Malfait </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Computing prime numbers in parallel</h1> <p class="post-meta"> June 05, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/programming"> <i class="fa-solid fa-hashtag fa-sm"></i> programming</a>   <a href="/blog/tag/rust"> <i class="fa-solid fa-hashtag fa-sm"></i> rust</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="the-problem-statement">The problem statement</h2> <p>Given an integer <code class="language-plaintext highlighter-rouge">n</code>, the goal is to compute all the prime numbers less than or equal to <code class="language-plaintext highlighter-rouge">n</code>.</p> <p>Most programmers have probably written a program to do exactly this at least once in their life. I recently needed this for <a href="https://github.com/WannesMalfait/prime-sum-sequences" rel="external nofollow noopener" target="_blank">a program</a> I was writing to compute “prime sum sequences”: permutations of the numbers <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">n</code> such that the sum of two consecutive numbers is always a prime, e.g., <code class="language-plaintext highlighter-rouge">1,4,3,2,5,6</code>.</p> <h2 id="the-solution">The solution</h2> <p>We will be writing all the code in rust, because I like writing things in rust, and because it is easy to write high-performance parallel code in.</p> <h3 id="a-naive-implementation">A naive implementation</h3> <p>Let us start with perhaps the most simple implementation:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">compute_primes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="n">i</span><span class="p">)</span><span class="nf">.all</span><span class="p">(|</span><span class="n">divisor</span><span class="p">|</span> <span class="n">i</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
        <span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>We make heavy use of iterators here. The code almost reads like the definition of a prime number: A number \(i &gt; 1\) is prime, if it has no non-trivial divisors, i.e., for all \(j \in {2, 3, \dotsc, i -1 }\), the number \(j\) does not divide \(i\). For those less familiar with iterators, here is a version with classic for loops:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">compute_primes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">primes</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..=</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">is_prime</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">divisor</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..</span><span class="n">i</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">is_prime</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
                <span class="k">break</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">is_prime</span> <span class="p">{</span>
            <span class="n">primes</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">primes</span>
<span class="p">}</span>
</code></pre></div></div> <p>Let us now clean this up a bit by splitting the primality check into a separate function:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">..*</span><span class="n">n</span><span class="p">)</span><span class="nf">.all</span><span class="p">(|</span><span class="n">divisor</span><span class="p">|</span> <span class="n">n</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">compute_primes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.filter</span><span class="p">(</span><span class="n">is_prime</span><span class="p">)</span><span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>It is now trivial to parallelize this with rayon:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">rayon</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">..*</span><span class="n">n</span><span class="p">)</span><span class="nf">.all</span><span class="p">(|</span><span class="n">divisor</span><span class="p">|</span> <span class="n">n</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">compute_primes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.into_par_iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(</span><span class="n">is_prime</span><span class="p">)</span><span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>That is quite elegant and neat. We can still speed this up by a lot, because we are doing a lot of redundant work.</p> <h3 id="removing-redundant-checks">Removing redundant checks</h3> <p>Observe that if \(n = a \cdot b\), then either \(a \leq \sqrt{n}\) or \(b \leq \sqrt{n}\). Indeed, otherwise we would have \(a &gt; \sqrt{n}\) and \(b &gt; \sqrt{n}\) from which \[ n = a \cdot b &gt; \sqrt{n} \cdot \sqrt{n} = n, \] a contradiction. So, it suffices to check for divisors less than the square root of \(n\). Alternatively, one can check that the square of the divisor is less than \(n\). To avoid potential overflows we use a saturated multiplication:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="c1">// Note that i &lt;= sqrt(n) if and only if i^2 &lt;= n.</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">..*</span><span class="n">n</span><span class="p">)</span>
        <span class="nf">.take_while</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span><span class="nf">.saturating_mul</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
        <span class="nf">.all</span><span class="p">(|</span><span class="n">divisor</span><span class="p">|</span> <span class="n">n</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>Note that this is a big reduction in complexity, e.g., to check if 1000 is prime we now only need to check 31 numbers, instead of 1000.</p> <p>The next observation is that we only need to check if the number is divisible by prime numbers, since every number is a product of prime numbers. However, to implement this, we already need a list of prime numbers! Luckily we can get around this:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// `primes` should contain at least all primes less than sqrt(n).</span>
<span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">primes</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="n">primes</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.take_while</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span><span class="nf">.saturating_mul</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
        <span class="nf">.all</span><span class="p">(|</span><span class="n">prime</span><span class="p">|</span> <span class="n">n</span> <span class="o">%</span> <span class="n">prime</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">compute_primes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// We can no longer use filter -&gt; collect,</span>
    <span class="c1">// because we need primes while iterating.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">primes</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..=</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primes</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">primes</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">primes</span>
<span class="p">}</span>
</code></pre></div></div> <p>The good news is that this also gives a nice reduction in complexity. One can show that the number of primes less than \(n\) is approximately \(n / \ln{n}\), where \(\ln\) denotes the natural logarithm. So we have gone from \(O(n)\) to \(O(\sqrt{n})\) to \[ O\left(\frac{\sqrt(n)}{\ln{\sqrt(n)}}\right) = O\left(2 \cdot \frac{\sqrt{n}}{\ln{n}}\right) = O\left(\frac{\sqrt{n}}{\ln{n}}\right). \] Concretely, from checking 1000 numbers, to checking 30 numbers, to checking just 11. For 10000, we go to 100 and then down to 25. That is quite the reduction!</p> <p>The bad news is that we have lost our parallel iterator. We will now see how we can get it back.</p> <h3 id="back-to-parallelism">Back to parallelism</h3> <p>The main issue is that our main loop has gone from a parallel loop to a sequential one. Previously, the <code class="language-plaintext highlighter-rouge">is_prime</code> function only depended on the current number in the loop. Now, <code class="language-plaintext highlighter-rouge">is_prime</code> also depends on the already computed list of primes. Thus, <code class="language-plaintext highlighter-rouge">is_prime(n+1)</code> can only be computed after <code class="language-plaintext highlighter-rouge">is_prime(n)</code> has been computed. This prevents a simple parallelization of the loop.</p> <p>The key insight is that we don’t actually need to know all the primes up to <code class="language-plaintext highlighter-rouge">n</code> to compute <code class="language-plaintext highlighter-rouge">is_prime(n)</code>. As we already observed, we only need to know the primes up to \(\sqrt{n}\). For example, if we already know the primes up to 100, we can safely compute all the primes up to \(100^2 = 10000\) using the list of primes up to 100. This gives the final algorithm:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">rayon</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">min</span><span class="p">;</span>

<span class="c1">// `primes` should contain at least all primes less than sqrt(n).</span>
<span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">primes</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="n">primes</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.take_while</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span><span class="nf">.saturating_mul</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
        <span class="nf">.all</span><span class="p">(|</span><span class="n">prime</span><span class="p">|</span> <span class="n">n</span> <span class="o">%</span> <span class="n">prime</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">compute_primes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">primes</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="c1">// We first compute some initial primes on 1 thread,</span>
    <span class="c1">// since to properly iterate in parallel we need to already</span>
    <span class="c1">// have a decent number of primes.</span>
    <span class="k">let</span> <span class="n">initial_cutoff</span> <span class="o">=</span> <span class="mi">5_000</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cap</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">initial_cutoff</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..=</span><span class="n">cap</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primes</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">primes</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Now we can iterate in parallel.</span>
    <span class="k">while</span> <span class="n">cap</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">// We know the primes up to cap,</span>
        <span class="c1">// so we can compute the primes up to</span>
        <span class="c1">// cap^2.</span>
        <span class="n">cap</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">cap</span><span class="nf">.saturating_mul</span><span class="p">(</span><span class="n">cap</span><span class="p">));</span>

        <span class="k">let</span> <span class="n">new_primes</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="o">..=</span><span class="n">cap</span><span class="p">)</span>
            <span class="nf">.into_par_iter</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primes</span><span class="p">))</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>
        <span class="n">primes</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_primes</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">primes</span>
<span class="p">}</span>
</code></pre></div></div> <p>For my laptop with 8 threads, this parallel version was around 6 times faster than the single-threaded version. This indicates that the parallelism works quite well.</p> <h2 id="closing-remarks">Closing remarks</h2> <p>The final algorithm as it is written is not fully optimized. Things that could be added include:</p> <ul> <li>Only iterate over odd numbers. This seems like it halves execution time, but in reality doesn’t make a big difference. The reason is that being even is always the first thing being checked in <code class="language-plaintext highlighter-rouge">is_prime</code>, so skipping over even numbers only skips numbers that would be rejected quickly anyway.</li> <li>Allocate space for the <code class="language-plaintext highlighter-rouge">primes</code> vector ahead of time using the <code class="language-plaintext highlighter-rouge">n / ln(n)</code> approximation for its size. This might give a minor improvement in speed.</li> <li>Choose an <code class="language-plaintext highlighter-rouge">initial_cutoff</code> value depending on the number of threads. The value I picked is somewhat arbitrary, but seemed to work well on my laptop.</li> </ul> <p>I decided to make this blog post because I couldn’t find any decent parallel prime generating functions when I searched for it online. After thinking about it a bit myself, I ended up with the above algorithm and then made this blog post, so others can use it too. Over all, I am quite pleased with the result.</p> </div> </article> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2024 Wannes Malfait. Last updated: September 20, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?da39b660470d1ba6e6b8bf5f37070b6e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>